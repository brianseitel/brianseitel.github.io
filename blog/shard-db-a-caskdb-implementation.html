<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Shard DB: A CaskDB Implementation | The Gleeman&#39;s Tales</title>
    <meta name="generator" content="Gleeman v1.0.0" />
    <meta property="og:title" content="Shard DB: A CaskDB Implementation" />
    <meta name="author" content="Brian Seitel" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:site_name" content="The Gleeman&#39;s Tales" />

    
    <link rel="stylesheet" href="assets/main.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

    
    <link rel="icon" type="image/png" sizes="32x32" href="/tale/assets/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/tale/assets/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/tale/assets/apple-touch-icon.png">
</head>

<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="/">
                <h2 class="nav-title">The Gleeman&#39;s Tales</h2>
            </a>
            
        </div>
    </nav>


    <main>
        <div class="post">
            <div class="post-info">
                <span>Written by</span>

                Brian Seitel
                <br>
                <span>on&nbsp;</span><time datetime="2017-03-29 00:00:00 +0000">2022-12-01</time>

            </div>

            <h1 class="post-title">Shard DB: A CaskDB Implementation</h1>
            
            <div class="post-line"></div>

            <hr>

<h1>Shard DB: A Cask DB implementation</h1>

<p>I've been writing code for my entire adult life, but I've never felt like I truly understood some of the really complex tech that powers so much of our lives. For example, I'm endlessly fascinated that people can just write programs <a href="https://jason.today/little-worlds">to procedurally generate graphical worlds</a>. I don't even know how to begin generating graphics. But in the last 10 years, I've spent a lot of time working with various datastores, from MySQL to Elasticsearch to Redis, and I think I understand how all the pieces fit together at a high level.</p>

<p>That's why I was really excited to stumble upon <a href="https://riak.com/assets/bitcask-intro.pdf">Riak's CaskDB paper</a>. Go ahead. Read it. It's only six pages long, and most of that consists of diagrams.</p>

<p>And I thought to myself... why not give it a shot? It's fairly straightforward!</p>

<p>All code below is in Go, which is my preferred language, although this code should be simple enough to implement in any language you choose.</p>

<h2>How it Works</h2>

<p>At its core, Cask is a hybrid file-based and memory-based key-value datastore. We store the keys and values to disk in append-only files, and we store the keys and value <em>positions</em> in memory. The files are append-only, which means writes are extremely fast. This does mean that files can get large, but that gets addressed a little later.</p>

<h3>File-based data structure</h3>

<p>Imagine we have the following data:</p>

<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td>name</td>
<td>Maximus Pegasus</td>
</tr>
</tbody>
</table>
<p>Given this particular key/value pair, we need to generate some information, then generate a fixed-length header to give us some metadata about the key and value. The fixed-length header is a total of 16 bytes:</p>

<ul>
<li>Timestamp (64 bits / 8 bytes)</li>
<li>Key Size (32 bits / 4 bytes)</li>
<li>Value Size (32 bits / 4 bytes)</li>
</ul>

<p>Then we'll append the <code>{header}{key}{value}</code> as bytes in the data file, recording the position where this entry begins.</p>

<p>In the above example, we have a key size of <code>len(name) -&gt; 4</code> and a value size of <code>len(value) -&gt; 15</code>. So our fixed header would be something along the lines of:</p>

<table>
<thead>
<tr>
<th>timestamp</th>
<th>key_size</th>
<th>value_size</th>
<th>key</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td>1652215185</td>
<td>4</td>
<td>15</td>
<td>name</td>
<td>Maximus Pegasus</td>
</tr>
</tbody>
</table>
<p>The total length of this record would be:</p>

<p><code>16 (fixed-length header) + 4 (key) + 15 (value) = 31 bytes</code>.</p>

<p>Note: as I mentioned earlier, the data store files are <em>append-only</em>, so as we add or update new data, they get tacked onto the end of the file. You wind up with something like this:</p>

<p><img src="/images/01-shard-filestructure.png" alt="A visual representation of the file structure" /></p>

<h3>Memory-based data structure</h3>

<p>Now that we've established our file format, we need some way to look up this data. Riak's CaskDB spec has a pretty elegant solution: a key directory. At its core, it's basically a hashmap where the key is... well, the key, and the map contains the value size and the position of the record.</p>

<p>Imagine we have the following records:</p>

<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td>name</td>
<td>Maximus Pegasus</td>
</tr>

<tr>
<td>job</td>
<td>Chief Wing Repair Officer</td>
</tr>

<tr>
<td>age</td>
<td>23</td>
</tr>

<tr>
<td>legs</td>
<td>4</td>
</tr>

<tr>
<td>wings</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Our file would look something like this:</p>

<table>
<thead>
<tr>
<th>timestamp</th>
<th>key_size</th>
<th>value_size</th>
<th>key</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td>1652215185</td>
<td>4</td>
<td>15</td>
<td>name</td>
<td>Maximus Pegasus</td>
</tr>

<tr>
<td>1652216123</td>
<td>3</td>
<td>25</td>
<td>job</td>
<td>Chief Wing Repair Officer</td>
</tr>

<tr>
<td>1652218141</td>
<td>3</td>
<td>2</td>
<td>age</td>
<td>23</td>
</tr>

<tr>
<td>1652219662</td>
<td>4</td>
<td>1</td>
<td>legs</td>
<td>4</td>
</tr>

<tr>
<td>1652212031</td>
<td>5</td>
<td>1</td>
<td>wings</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>The length of each record would be 31, 44, 21, 21, and 22 bytes, respectively. This is important, so keep this in mind for now.</p>

<p>Now we need to construct our Key Directory. The Key Directory is basically a list of the keys, the value lengths, and the positions of those records. Those record lengths above? Those values are used to determine the <code>ValuePosition</code>. Given the above examples, you would have a file with records at these offsets:</p>

<table>
<thead>
<tr>
<th>key</th>
<th>length</th>
<th>offset (sum of previous lengths)</th>
</tr>
</thead>

<tbody>
<tr>
<td>name</td>
<td>31</td>
<td>0</td>
</tr>

<tr>
<td>job</td>
<td>44</td>
<td>31</td>
</tr>

<tr>
<td>age</td>
<td>21</td>
<td>75</td>
</tr>

<tr>
<td>legs</td>
<td>21</td>
<td>96</td>
</tr>

<tr>
<td>wings</td>
<td>22</td>
<td>118</td>
</tr>
</tbody>
</table>
<p>Why is this useful? Well, it means that when we look up the key <code>age</code>, we know exactly where to start parsing the record! It starts at byte 75!</p>

<h2>The Code</h2>

<p>OK, now that we know how this works, more or less, we can start writing some code. We'll break this up into five parts:</p>

<ol>
<li>The fixed-length header</li>
<li>The variable-length key/values</li>
<li>Writing to Disk</li>
<li>Creating the Key Directory</li>
<li>Read a value from disk</li>
</ol>

<h3>The Header</h3>

<p>First, we'll define our fixed-length header:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> Header <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    Timestamp <span style="color:#458;font-weight:bold">int64</span>
</span></span><span style="display:flex;"><span>    KeySize <span style="color:#458;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>    ValSize <span style="color:#458;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p><em>Note: I know that the Riak Bitcask paper says the timestamp should be int32, but Go returns Unix timestamps in 64-bit integers, and I feel like that's acceptable, so I'm leaving it at 64 bits.</em></p>

<p>Next, we need to encode our <code>Header</code> into bytes. This is pretty easy with Go's <code>bytes</code> package:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (h Header) <span style="color:#900;font-weight:bold">Encode</span>() []<span style="color:#458;font-weight:bold">byte</span> {
</span></span><span style="display:flex;"><span>    buf <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">new</span>(bytes.Buffer)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    binary.<span style="color:#900;font-weight:bold">Write</span>(buf, binary.LittleEndian, h.Timestamp)
</span></span><span style="display:flex;"><span>	binary.<span style="color:#900;font-weight:bold">Write</span>(buf, binary.LittleEndian, h.KeySize)
</span></span><span style="display:flex;"><span>	binary.<span style="color:#900;font-weight:bold">Write</span>(buf, binary.LittleEndian, h.ValSize)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> buf.<span style="color:#900;font-weight:bold">Bytes</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>Decoding this is a little more complicated, but only because we're dealing with variable byte sizes. If we look at our Header, we have the following sizes:</p>

<table>
<thead>
<tr>
<th>field</th>
<th>bits</th>
<th>bytes</th>
</tr>
</thead>

<tbody>
<tr>
<td>Timestamp</td>
<td>64</td>
<td>8</td>
</tr>

<tr>
<td>KeySize</td>
<td>32</td>
<td>4</td>
</tr>

<tr>
<td>ValSize</td>
<td>32</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>So, in order to decode, we need to do the following:</p>

<ol>
<li>Grab the next N bytes</li>
<li>Decode from bytes to appropriate integer value</li>
<li>Assign to struct</li>
</ol>

<p>The code would look something like this:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (h <span style="color:#000;font-weight:bold">*</span>Header) <span style="color:#900;font-weight:bold">Decode</span>(data []<span style="color:#458;font-weight:bold">byte</span>) {
</span></span><span style="display:flex;"><span>	reader <span style="color:#000;font-weight:bold">:=</span> bytes.<span style="color:#900;font-weight:bold">NewReader</span>(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ts <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">byte</span>, <span style="color:#099">8</span>)
</span></span><span style="display:flex;"><span>	_, err <span style="color:#000;font-weight:bold">:=</span> reader.<span style="color:#900;font-weight:bold">ReadAt</span>(ts, <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#0086b3">panic</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	ks <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">byte</span>, <span style="color:#099">4</span>)
</span></span><span style="display:flex;"><span>	_, err = reader.<span style="color:#900;font-weight:bold">ReadAt</span>(ks, <span style="color:#099">8</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#0086b3">panic</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	vs <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">byte</span>, <span style="color:#099">4</span>)
</span></span><span style="display:flex;"><span>	_, err = reader.<span style="color:#900;font-weight:bold">ReadAt</span>(vs, <span style="color:#099">12</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#0086b3">panic</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	h.Timestamp = <span style="color:#0086b3">int64</span>(binary.LittleEndian.<span style="color:#900;font-weight:bold">Uint64</span>(ts))
</span></span><span style="display:flex;"><span>	h.KeySize = <span style="color:#0086b3">int32</span>(binary.LittleEndian.<span style="color:#900;font-weight:bold">Uint32</span>(ks))
</span></span><span style="display:flex;"><span>	h.ValSize = <span style="color:#0086b3">int32</span>(binary.LittleEndian.<span style="color:#900;font-weight:bold">Uint32</span>(vs))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>First, we grab the first 8 bytes which represent the 64-bit timestamp. Then we grab the next 4 bytes, which represent the 32-bit key size, and then we grab the final 4 bytes, which represent the 32-bit value size. Now we have our fixed-length header!</p>

<p>Here's a quick unit test to sanity check ourselves:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">TestEncodeKV</span>(t <span style="color:#000;font-weight:bold">*</span>testing.T) {
</span></span><span style="display:flex;"><span>	kv <span style="color:#000;font-weight:bold">:=</span> KeyValue{
</span></span><span style="display:flex;"><span>		Timestamp: time.<span style="color:#900;font-weight:bold">Now</span>().<span style="color:#900;font-weight:bold">Unix</span>(),
</span></span><span style="display:flex;"><span>		Key:       <span style="color:#d14">&#34;name&#34;</span>,
</span></span><span style="display:flex;"><span>		Value:     <span style="color:#d14">&#34;Maximus Pegasus&#34;</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	size, data <span style="color:#000;font-weight:bold">:=</span> kv.<span style="color:#900;font-weight:bold">Encode</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#900;font-weight:bold">Println</span>(size)
</span></span><span style="display:flex;"><span>	result <span style="color:#000;font-weight:bold">:=</span> KeyValue{}
</span></span><span style="display:flex;"><span>	result.<span style="color:#900;font-weight:bold">Decode</span>(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	assert.<span style="color:#900;font-weight:bold">Equal</span>(t, result.Timestamp, kv.Timestamp)
</span></span><span style="display:flex;"><span>	assert.<span style="color:#900;font-weight:bold">Equal</span>(t, result.Key, kv.Key)
</span></span><span style="display:flex;"><span>	assert.<span style="color:#900;font-weight:bold">Equal</span>(t, result.Value, kv.Value)
</span></span><span style="display:flex;"><span>	assert.<span style="color:#900;font-weight:bold">Equal</span>(t, result.Size, size)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<h3>The Variable Length Keys / Values</h3>

<p>If you recall from the Bitcask paper and our explanation above, our entire record is composed of the fixed-length header that we just created, plus the actual key and actual value.</p>

<p>I called this a <code>KeyValue</code> item, and it looks something like this:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> KeyValue <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	Key       <span style="color:#458;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>	Value     <span style="color:#458;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>	Size      <span style="color:#458;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p><em>Note: the <code>Size</code> field is primarily for sanity-checking our work later. It's not strictly necessary here.</em></p>

<p>We'll encode this struct in exactly the same was awe did the header -- but this record would actually include the header as well, which we can construct from the key and value!</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (kv KeyValue) <span style="color:#900;font-weight:bold">Encode</span>() (<span style="color:#458;font-weight:bold">int</span>, []<span style="color:#458;font-weight:bold">byte</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	header <span style="color:#000;font-weight:bold">:=</span> Header{
</span></span><span style="display:flex;"><span>		Timestamp: kv.Timestamp,
</span></span><span style="display:flex;"><span>		KeySize:   <span style="color:#0086b3">int32</span>(<span style="color:#0086b3">len</span>(kv.Key)),
</span></span><span style="display:flex;"><span>		ValSize:   <span style="color:#0086b3">int32</span>(<span style="color:#0086b3">len</span>(kv.Value)),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	buf <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">new</span>(bytes.Buffer)
</span></span><span style="display:flex;"><span>	buf.<span style="color:#900;font-weight:bold">Write</span>(header.<span style="color:#900;font-weight:bold">Encode</span>())
</span></span><span style="display:flex;"><span>	buf.<span style="color:#900;font-weight:bold">Write</span>([]<span style="color:#0086b3">byte</span>(kv.Key))
</span></span><span style="display:flex;"><span>	buf.<span style="color:#900;font-weight:bold">Write</span>([]<span style="color:#0086b3">byte</span>(kv.Value))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> buf.<span style="color:#900;font-weight:bold">Len</span>(), buf.<span style="color:#900;font-weight:bold">Bytes</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>First, we create the Header based on the length of the key and the value and the timestamp and encode that to a byte slice. Once we have that, we simply put that at the beginning of our bytes buffer, then add the bytes for the key and value, and voila! Our record!</p>

<p>Decoding it is once again as simple as decoding the Header, with the exact same idea. This time, we'll decode the Header first, so that we know how many bytes long the key and value are, then skip ahead 16 bytes to grab the key and value.</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> (kv <span style="color:#000;font-weight:bold">*</span>KeyValue) <span style="color:#900;font-weight:bold">Decode</span>(data []<span style="color:#458;font-weight:bold">byte</span>) {
</span></span><span style="display:flex;"><span>	reader <span style="color:#000;font-weight:bold">:=</span> bytes.<span style="color:#900;font-weight:bold">NewReader</span>(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	header <span style="color:#000;font-weight:bold">:=</span> Header{}
</span></span><span style="display:flex;"><span>	header.<span style="color:#900;font-weight:bold">Decode</span>(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	offset <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">int64</span>(<span style="color:#099">16</span>)
</span></span><span style="display:flex;"><span>	key <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">byte</span>, header.KeySize)
</span></span><span style="display:flex;"><span>	_, err <span style="color:#000;font-weight:bold">:=</span> reader.<span style="color:#900;font-weight:bold">ReadAt</span>(key, offset)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#0086b3">panic</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	offset <span style="color:#000;font-weight:bold">+=</span> <span style="color:#0086b3">int64</span>(<span style="color:#0086b3">len</span>(key))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	value <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">byte</span>, header.ValSize)
</span></span><span style="display:flex;"><span>	_, err = reader.<span style="color:#900;font-weight:bold">ReadAt</span>(value, offset)
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#0086b3">panic</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	kv.Timestamp = header.Timestamp
</span></span><span style="display:flex;"><span>	kv.Key = <span style="color:#0086b3">string</span>(key)
</span></span><span style="display:flex;"><span>	kv.Value = <span style="color:#0086b3">string</span>(value)
</span></span><span style="display:flex;"><span>	kv.Size = <span style="color:#0086b3">len</span>(data)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<h3>Writing to Disk</h3>

<p>Now that we can encode and decode our data, it's time to write that to disk. In the Bitcask paper, the rule is that you can only write to one file at a time -- the &quot;active&quot; file -- and so this part is fairly easy! Let's just write to a single file for now.</p>

<p>First, we'll load a file that will allow us to write in append mode:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">loadFile</span>(path <span style="color:#458;font-weight:bold">string</span>) <span style="color:#458;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>    f, err <span style="color:#000;font-weight:bold">:=</span> os.<span style="color:#900;font-weight:bold">OpenFile</span>(file, os.O_RDWR, fs.ModeAppend)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">handleError</span>(err) <span style="color:#998;font-style:italic">// whatever this means to you
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> f
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>Next, we'll create a function to set our key and value, then encode our key/value with the functions we created above. It would look something like this:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">Set</span>(key <span style="color:#458;font-weight:bold">string</span>, value <span style="color:#458;font-weight:bold">string</span>) <span style="color:#458;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>    timestamp <span style="color:#000;font-weight:bold">:=</span> time.<span style="color:#900;font-weight:bold">Now</span>().<span style="color:#900;font-weight:bold">Unix</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    kv <span style="color:#000;font-weight:bold">:=</span> KeyValue{
</span></span><span style="display:flex;"><span>        Timestamp: timestamp,
</span></span><span style="display:flex;"><span>        Key: key,
</span></span><span style="display:flex;"><span>        Value: value,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    size, data <span style="color:#000;font-weight:bold">:=</span> kv.<span style="color:#900;font-weight:bold">Encode</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">loadFile</span>(<span style="color:#d14">&#34;test.db&#34;</span>)
</span></span><span style="display:flex;"><span>    position, _ <span style="color:#000;font-weight:bold">:=</span> f.<span style="color:#900;font-weight:bold">Seek</span>(<span style="color:#099">0</span>, io.SeekEnd) <span style="color:#998;font-style:italic">// set the offset at the end of the file -- append-only, remember?
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    n, err <span style="color:#000;font-weight:bold">:=</span> f.<span style="color:#900;font-weight:bold">Write</span>(data) <span style="color:#998;font-style:italic">// write the data to disk
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">handleError</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Lets&#39; sanity check ourselves to make sure we wrote what we thought we were going to write
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> n <span style="color:#000;font-weight:bold">!=</span> size {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> log.<span style="color:#900;font-weight:bold">Fatalf</span>(<span style="color:#d14">&#34;Oops! Failed to write expected length! Expected %d, got %d!&#34;</span>, size, n)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// No problem!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>That's it! Now we've encoded our <code>KeyValue</code> and written it to disk.</p>

<p><em>Level Up Opportunity: to clean this up further, don't load the file on every <code>Set</code> command, but instead keep the file-handler in memory. I'll leave this as an exercise to you!</em></p>

<h3>Create the Key Directory</h3>

<p>We need to do one more thing before we move on, and that's add this key to the Key Directory. The Key Directory is the gizmo that lets us find the values we've already written. As discussed above, the Key Directory is fairly simple, and it looks like this:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">var</span> KeyDirectory = <span style="color:#0086b3">make</span>(<span style="color:#000;font-weight:bold">map</span>[<span style="color:#458;font-weight:bold">string</span>]KeyEntry)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">type</span> KeyEntry <span style="color:#000;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>    Timestamp <span style="color:#458;font-weight:bold">int64</span>
</span></span><span style="display:flex;"><span>    ValueSize <span style="color:#458;font-weight:bold">int32</span>
</span></span><span style="display:flex;"><span>    ValuePosition <span style="color:#458;font-weight:bold">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<p>The <code>KeyDirectory</code> is just a <code>map[string]KeyEntry</code> where the key is the... well, the key, and the value is a struct that tells us where in the active file to find that key. Pretty simple!</p>

<p>At the end of your <code>Set</code> function, simply add this code:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span>keyEntry <span style="color:#000;font-weight:bold">:=</span> KeyEntry{
</span></span><span style="display:flex;"><span>    Timestamp: timestamp,
</span></span><span style="display:flex;"><span>    ValueSize: <span style="color:#0086b3">int32</span>(size),
</span></span><span style="display:flex;"><span>    ValuePosition: position,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>KeyDirectory[key] = keyEntry
</span></span></code></pre>
<p>This simply creates the Key Directory entry and puts it into memory!</p>

<p>Your final code for the <code>Set</code> function should look like this:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">Set</span>(key <span style="color:#458;font-weight:bold">string</span>, value <span style="color:#458;font-weight:bold">string</span>) <span style="color:#458;font-weight:bold">error</span> {
</span></span><span style="display:flex;"><span>    timestamp <span style="color:#000;font-weight:bold">:=</span> time.<span style="color:#900;font-weight:bold">Now</span>().<span style="color:#900;font-weight:bold">Unix</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    kv <span style="color:#000;font-weight:bold">:=</span> KeyValue{
</span></span><span style="display:flex;"><span>        Timestamp: timestamp,
</span></span><span style="display:flex;"><span>        Key: key,
</span></span><span style="display:flex;"><span>        Value: value,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    size, data <span style="color:#000;font-weight:bold">:=</span> kv.<span style="color:#900;font-weight:bold">Encode</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">loadFile</span>(<span style="color:#d14">&#34;test.db&#34;</span>)
</span></span><span style="display:flex;"><span>    position, _ <span style="color:#000;font-weight:bold">:=</span> f.<span style="color:#900;font-weight:bold">Seek</span>(<span style="color:#099">0</span>, io.SeekEnd) <span style="color:#998;font-style:italic">// set the offset at the end of the file -- append-only, remember?
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    n, err <span style="color:#000;font-weight:bold">:=</span> f.<span style="color:#900;font-weight:bold">Write</span>(data) <span style="color:#998;font-style:italic">// write the data to disk
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#900;font-weight:bold">handleError</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// Lets&#39; sanity check ourselves to make sure we wrote what we thought we were going to write
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">if</span> n <span style="color:#000;font-weight:bold">!=</span> size {
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">return</span> log.<span style="color:#900;font-weight:bold">Fatalf</span>(<span style="color:#d14">&#34;Oops! Failed to write expected length! Expected %d, got %d!&#34;</span>, size, n)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    keyEntry <span style="color:#000;font-weight:bold">:=</span> KeyEntry{
</span></span><span style="display:flex;"><span>        Timestamp: timestamp,
</span></span><span style="display:flex;"><span>        ValueSize: <span style="color:#0086b3">int32</span>(size),
</span></span><span style="display:flex;"><span>        ValuePosition: position,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    KeyDirectory[key] = keyEntry
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// No problem!
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#000;font-weight:bold">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<h3>Read value from disk</h3>

<p>Now that we've written to disk and created our Key Directory, actually grabbing the value from disk couldn't be simpler. It follows three basic steps:</p>

<ol>
<li>Grab the <code>KeyEntry</code> from the key directory map</li>
<li>Seek to the <code>ValuePosition</code></li>
<li>Decode the <code>KeyValue</code> record starting from that position!</li>
</ol>

<p><em>Note: technically, you could grab <em>just</em> the value since we know the size, but since we've already written the code to decode the whole record, why not just do that as well? It's going to be just as fast in 99.999% of cases.</em></p>

<p>You could probably write this code yourself, but just in case, here's how I might do it:</p>
<pre tabindex="0" style="background-color:#fff;"><code><span style="display:flex;"><span><span style="color:#000;font-weight:bold">func</span> <span style="color:#900;font-weight:bold">Get</span>(key <span style="color:#458;font-weight:bold">string</span>) <span style="color:#458;font-weight:bold">string</span> {
</span></span><span style="display:flex;"><span>    f <span style="color:#000;font-weight:bold">:=</span> <span style="color:#900;font-weight:bold">loadFile</span>(<span style="color:#d14">&#34;test.db&#34;</span>)
</span></span><span style="display:flex;"><span>    keyEntry, ok <span style="color:#000;font-weight:bold">:=</span> KeyDirectory[key]
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> !ok {
</span></span><span style="display:flex;"><span>        log.<span style="color:#900;font-weight:bold">Fatalf</span>(<span style="color:#d14">&#34;Invalid key %s&#34;</span>, key)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    f.<span style="color:#900;font-weight:bold">Seek</span>(<span style="color:#099">0</span>, <span style="color:#0086b3">int</span>(keyEntry.ValuePosition)) <span style="color:#998;font-style:italic">// jump to the offset of the record
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    data, <span style="color:#000;font-weight:bold">:=</span> <span style="color:#0086b3">make</span>([]<span style="color:#458;font-weight:bold">byte</span>, keyEntry.ValueSize)
</span></span><span style="display:flex;"><span>    _, err <span style="color:#000;font-weight:bold">:=</span> f.<span style="color:#900;font-weight:bold">Read</span>(data)
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">if</span> err <span style="color:#000;font-weight:bold">!=</span> <span style="color:#000;font-weight:bold">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#0086b3">panic</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    entry <span style="color:#000;font-weight:bold">:=</span> <span style="color:#000;font-weight:bold">&amp;</span>KeyValue{}
</span></span><span style="display:flex;"><span>    entry.<span style="color:#900;font-weight:bold">Decode</span>(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">string</span>(entry.Value)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
<h2>Next Steps</h2>

<p>Now that you have a functioning key/value store that persists data to disk and keeps its access lookup in memory, you're pretty much ready to rock. There are some optimizations to make, and the Riak Bitcask paper has some ideas on how to improve it. Here are just a few of them:</p>

<ul>
<li>Organize your code to keep the active file handler in memory instead of loading it on get/set.</li>
<li>Since the file is append-only, you will eventually get duplicate records and file sizes can explode. Once the file hits a certain size, migrate the data to a newer, smaller file.</li>
<li>Create a Hint File (see Riak Bitcask docs for more explanation) to speed up app startup times.</li>
<li>Allow reads from older files instead of the only active file. (Remember: writes will only go to the active file handler!).</li>
<li>Right now our Bitcask implementation only supports string values. Modify this to support multiple value types: ints, floats, strings, bytes, maybe even complex data structures.</li>
</ul>

        </div>
    </main>

<footer>
    <span>
        &copy; <time datetime="2023-03-01T13:21:47-08:00">2023</time> All rights reserved.
    </span>
</footer>
</body>

</html>